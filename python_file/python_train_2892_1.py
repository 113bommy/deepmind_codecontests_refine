# salsa=0, rumba=1
# [0 1 0 1] 1より上の位に帯する操作

# 繰り上がりを考慮しつつ、3（より上）の位に対する操作を考える
# [1]       1の位が0である数字の、3の位に対する操作
# [0 1 0]   1の位が1である数字の、3の位に対する操作
# []        1の位が2である数字の、3の位に対する操作
# ある数字が"2"の時にルンバが来れば繰り上がる（上の位にルンバが波及）
# それ以外の状態では、上の位にとってルンバは無いのと同じことになる
# サルサは常に影響するが、連続した2つのサルサは打ち消し合い、無いのと同じことになる

# 再帰的に上の位を決める
# []        3,1の位が00,10である数字の、9の位に対する操作
# [1]       3,1の位が20である数字の、9の位に対する操作
# []        3,1の位が01,21である数字の、9の位に対する操作
# [0 1 0]   3,1の位が11である数字の、9の位に対する操作
# []        3,1の位が02,12,22である数字の、9の位に対する操作

# 一度繰り上がったら、例えば100.. と0がd個続くとして、
# 更にその上の位に波及させるには 2^d オーダーの操作が必要となるので、各操作列は徐々に減っていく

n = int(input())
t = input()
op = [[int(c == 'R') for c in t]]
ans = [0]

for d in range(n):
    k = 3 ** d
    nop = []
    nans = [0] * (k * 3)
    for g in range(3):  # d桁目の数
        for i in range(k):  # d桁目未満の数
            opg = op[i]
            opn = []
            h = g
            for o in opg:
                if o == 0:
                    if len(opn) > 0 and opn[-1] == 0:
                        opn.pop()
                    else:
                        opn.append(0)
                    if h == 1:
                        h = 2
                    elif h == 2:
                        h = 1
                else:
                    if h == 2:
                        h = 0
                        opn.append(1)
                    else:
                        h += 1
            nop.append(opn)
            nans[g * k + i] = h * k + ans[i]

    op = nop
    ans = nans

print(*ans)
